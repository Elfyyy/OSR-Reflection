
type
  TReflectInvItem = record(TReflectPointer)
{$IFNDEF CODEINSIGHT}
    InvSlot, Id: Integer;
    Name: string;
{$ENDIF}
  end;

  TReflectInvItemArray = Array of TReflectInvItem;

procedure TReflectInvItemArray.Init(_Id: Integer);
begin
  if Length(Self) = 0 then
    SetLength(Self, 1);
  Self[0].Id := _Id;
end;

procedure TReflectInvItemArray.Init(_Name: string);
  overload;
begin
  if Length(Self) = 0 then
    SetLength(Self, 1);
  Self[0].Name := _Name;
end;

procedure TReflectInvItemArray.Init; overload;
begin
  if Length(Self) = 0 then
    SetLength(Self, 1);
  Self[0].Id := 0;
  Self[0].Name := '';
end;

procedure TReflectInvItem.Init(_Id: Integer);
begin
  Self.Id := _Id;
end;

procedure TReflectInvItem.Init(_Name: string); overload;
begin
  Self.Name := _Name;
end;

procedure TReflectInvItem.Init; overload;
begin
  Self.Id := 0;
  Self.Name := '';
end;

function TReflectInvItem.GetName: string;
var
  Line: string;
  Id: Integer;
begin
  Id := Self.Id;
  Line := ItemCache.GetStrings(Id);
  Result := Between('''name'': ''', ''',', Line);
end;

function TReflectInvItem.GetInvActions: TStringArray;
var
  Line, Temp: string;
  Id: Integer;
begin
  Id := Self.Id;
  Line := ItemCache.GetStrings(Id);
  Temp := Between('''actions'': [''', ']', Line);
  Temp := Copy(Temp, 1, Length(Temp) - 1);
  Result := Explode(''',''',Temp);
end;

function TReflectInvItem.GetGroundActions: TStringArray;
var
  Line, Temp: string;
  Id: Integer;
begin
  Id := Self.Id;
  Line := ItemCache.GetStrings(Id);
  Temp := Between('''groundActions'': [''', ']', Line);
  Temp := Copy(Temp, 1, Length(Temp) - 1);
  Result := Explode(''',''',Temp);
end;

function TReflectInvItem.GetHighAlchValue: Integer;
var
  Line: string;
  Id: Integer;
begin
  Id := Self.Id;
  Line := ItemCache.GetStrings(Id);
  Result := StrToInt(Between('highAlchValue'': ', '}', Line));
end;

function TReflectInvItem.GetQuantity: Integer;
begin
  Result := Reflect.Smart.GetFieldArrayInt(Self.Reference,
        Widget_StackSizes, Self.InvSlot - 1);
end;

function TReflectInvItem.GetId: Integer;
begin
  Result := Self.Id;
end;

{$IFNDEF CODEINSIGHT}
procedure TReflectInvItemArray.GetAll;
var
  I, TheId, TheQuantity, Count: Integer;
  InvWidget: TReflectWidget;
begin
  Reflect.Mem.FreeObjects(ckInvItems, False);
  InvWidget.GetWidget(WIDGET_Inventory_Container, 0);
  for I := 0 to 27 do
  begin
    TheId := Reflect.Smart.GetFieldArrayInt(
      InvWidget.Reference, Widget_InvIDs, I);
    if (TheId > 0) then
    begin
      Inc(Count);
      SetLength(Self, Count);
      TheQuantity
      with Self[Count - 1] do
      begin
        Reference := InvWidget.Reference;
        Id := TheId - 1;
        InvSlot := I + 1;
      end;
    end;
  end;
end;
{$ENDIF}

procedure TReflectInvItemArray.Get;
var
  Temp, Temp1: TReflectInvItemArray;
  I, H, T: integer;
begin
  if Length(Self) = 0 then
  begin
    Reflect.Logger.Warn('TReflectInvItemArray is not initialized @.Get');
    Exit;
  end;
  if (Self[0].Id = 0) and (Self[0].Name = '')then
  begin
    Self.GetAll;
    Exit;
  end;
  Temp := Self;
  Temp.GetAll;
  if Length(Temp) = 0 then
    Exit;
  if Self[0].Id = 0 then
  begin
    H := High(Temp);
    SetLength(Temp1, H + 1);
    for I := 0 to H do
    begin
      if (Temp[I].GetName = Self[0].Name) then
      begin
        Temp1[T] := Temp[I];
        Inc(T);
      end;
    end;
  end
  else
  begin
    H := High(Temp);
    Setlength(Temp1, H + 1);
    for I := 0 to H do
    begin
      if (Temp[I].GetId = Self[0].Id) then
      begin
        Temp1[T] := Temp[I];
        Inc(T);
      end;
    end;
  end;
  Setlength(Temp1, T);
  Self := Temp1;
end;

function TReflectInvItem.Find: Boolean;
var
  Temp: TReflectInvItemArray;
begin
  if (Self.Name = '') and (Self.Id = 0) then
  begin
    Reflect.Logger.Warn('TReflectInvItem is not initialized @ .Find');
    Exit;
  end;
  if Self.Name = '' then
    Temp.Init(Self.Id);
  if Self.Id = 0 then
    Temp.Init(Self.Name);
  Temp.Get;
  if Length(Temp) > 0 then
  begin
    Result := True;
    Self := Temp[0];
  end;
end;

function TReflectInvItem.GetMainScreenPoint: TPoint;
var
  Slot1, Slot6, Temp: TBox;
  Pnt: TPoint;
begin
  if not InRange(Self.InvSlot, 1, 28) then
    Exit;
  Slot1 := [563, 213, 594, 244];
  Slot6 := [605, 249, 31415, 92653];
  Temp.X1 := Slot1.X1 + ((((Self.InvSlot + 3) mod 4)) * (Slot6.X1 - Slot1.X1));
  Temp.Y1 := Slot1.Y1 + ((((Self.InvSlot - 1) div 4)) * (Slot6.Y1 - Slot1.Y1));
  Temp.X2 := Temp.X1 + (Slot1.X2 - Slot1.X1);
  Temp.Y2 := Temp.Y1 + (Slot1.Y2 - Slot1.Y1);
  Reflect.Math.GaussBox(Pnt.X, Pnt.Y, Temp.X1, Temp.Y1, Temp.X2, Temp.Y2);
  Result := Pnt;
end;

function TReflectionInv.Count: Integer;
var
  I: Integer;
  _Items: TReflectInvItemArray;
begin
  _Items.GetAll;
  Result := Length(_Items);
end;

function TReflectionInv.IsFull: Boolean;
begin
  Result := Reflect.Inv.Count = 28;
end;

